# Введение #

Перед Вами двжиок для рзработки 2D игр Isilme. Движок находится на раннем этапе разработки и постоянно меняется. Библиотека разрабатывается с ориентировкой на ролевые и стратегические игры и предоставляет несколько высокоуровневых абстракций в качестве интерфейса доступа к виртуальному миру.

Для чего был разработан этот движок? Никакой Великой Цели изначально не было, проект разрабатывался как платформа для проведения экспериментов (что будет если я напишу вот это..) и обучения. Для выполнения базовых функций, таких как рендеринг, воспроизведение звука и физическое моделирование используются различные открытые библиотеки. Isilme SDK -является лишь оберткой для этих библиотек и спроектирован так, что пользователю в большинстве случаев не придется работать с матрицами, полигонами текстурами, интегрированием, созданием и удалением объектов. Предполагается, что пользователь будет работать с объектами виртуального мира и некоторыми свойствами этих объектов.

Движок состоит из нескольких логических модулей, объединенных в одну библиотеку:
  * Core - базовая функциональность
  * AI - ИИ персонажей
  * Story - управление сюжетной линией
  * Palette - палитры объектов
  * Serialisation - алгоритмы сериализации
  * Inventory - управление инвентарем для ролевых игр

Движок ориентирован на работу с компилятором MS Visual C++ 2010, в дальнейшем будет проведена его адаптаций для GCC 4.7 или выше для платформ GNU Linux и Android

Эксперементальная поддержка iOS (GCC 4.2, XCode 4.3.3) добавлена в ветке iOS support.

# Установка #
### Требования ###
  1. Microsoft Visual Studio 2010 любой редакции
  1. Boost версии 1.47 или выше (скомпилированный)
  1. DircetX SDK (Требуется для сборки HGE)
### Установка SDK ###
Вы можете скачать архив с прекомпилированными библиотеками или собрать Isilme SDK самостоятельно, скачав его с репозитория.
Для сборки проекта, использующего SDK необходимо настроить переменные окружения среды:

> BOOST\_INCLUDE - путь к заголовочным файлам Boost

> BOOST\_LIB - путь к скомпилированным библиотекам Boost

> ISILME\_ROOT - путь к корневой директории Isilme SDK

> ISILME\_INCLUDE $(BOOST\_INCLUDE);$(ISILME\_ROOT);$(ISILME\_ROOT)/Guichan/include;$(ISILME\_ROOT)/HGE/include;$(ISILME\_ROOT)/Luabind;$(ISILME\_ROOT)/Lua/src;$(ISILME\_ROOT)/TinyXML/include;$(ISILME\_ROOT)/Squall/include;$(ISILME\_ROOT)/Engine/Include;$(ISILME\_ROOT)/Box2D

> ISILME\_LIB $(ISILME\_ROOT)/Box2d/lib;$(ISILME\_ROOT)/Engine/lib;$(ISILME\_ROOT)/Guichan/lib;$(ISILME\_ROOT)/HGE/lib;$(ISILME\_ROOT)/Squall/lib;$(ISILME\_ROOT)/Luabind/lib;$(ISILME\_ROOT)/Lua/lib;$(ISILME\_ROOT)/TinyXML/lib;

Если вы хотите собрать ISILME\_SDK самостоятельно, необходимо предварительно собрать все используемые сторонние библиотеки: Squall, HGE, HGEHelp, TinyXML, Box2D, Lua, Luabind, Guichan,  а затем собрать проект Engine.

### Настройка проекта ###

Необходимо создать проект Windows-приложения с точкой входа WinMain (хотя достаточно и обычного консольного приложения с main). В настройках проекта указать дополнительный путь к заголовочным файлам $(ISILME\_INCLUDE) и путь к дополнительным библиотекам $(ISILME\_LIB) требуемые версии сторонних библиотек (Debug/Release) будут прилинкованы автоматически.
# Основные концепции #
### Каркас приложения ###
Каркасом приложения является абстрактный класс Game. Базовые функции реализованы в классе HGEGame. Как следует из названия, рендеринг и управление ресурсами в нем осуществляется с помощью библиотеки HGE. При создании своего приложения необходимо реализовать методы инициализации в игре
```
class MyGame: public HGEGame
{
public:
	MyGame()
	{
	}
	virtual void Init()
	{
		// Загружаем мастер-файл
		FactoryManager::GetSingleton()->LoadMasterFile("../Data/Master.imf");

		// Создаем состояние
		StatePtr state(new MyState());

		// Помещаем состояние в стек	
		GetStateManager()->Push(playState);
	};
```

После того, как каркас приложения создан, в точке входа необходимо создать его экземпляр и запустить игровой цикл
```
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
	MyGame* game = new MyGame();
	game->Init();
	game->Start();
	delete game;

	return 0;
}
```
### Сущность ###
Объекты виртуального мира представлены сущностями (Entity). Каждая сущность состоит из графической модели (Graphics), физической модели (Body) и модели поведения (Behaviour). Каждая сущность имеет свой уникальный идентификатор, позволяющий получить доступ к объекту.
### Мастер-файл ###
Данные игры хранятся в различных файлах. Мастер-файл - это своеобразный файл проекта, в котором указаны ссылки на все компоненты игры. Мастер-файл (MasterFile) разбит на категории(Category), так что в каждой категории находятся компоненты (Entry) одного типа. В модуле Serialisation определены классы для чтения и записи компонентов базового типа из файлов.

Чтобы загрузить мастер-файл необходимо воспользоваться классом serialisation::MasterLoader.
```
serialisation::MasterLoader* loader(new serialisation::MasterLoader());
loader->Add("MyCategory", EntryLoaderPtr(new MyCategoryLoader()));

MasterFilePtr masterFile = loader->Load(fileName);
```

Настройку загрузчиков для базовых компонент производить не требуется, если только вы не желаете определить свой порядок загрузки или заменить тип компонента.
### Палитра ###
Палитра объектов описывает объекты, которые могут присутствовать в игровом мире. Палитры как правило являются одним из компонентов игры и указываются в мастер-файле в соответствующих категориях.

Существует несколько базовых палитр
  * Палитра графики (palette::GraphicsPalette)
  * Палитра сущностей (palette::EntityPalette)
  * Палитра пакетов ИИ (palette::AIPalette)
Описания объектов объектов запоминаются в соответствующих Def-классах, определениях, которые являются по совместительству фабриками объектов. Все определения перед использованием должны быть зарегистрированы в палитре, сделать это надлежит до загрузки мастер-файла.

### Состояние игры ###
Состояние игры (State) обрабатывает все логику сцены, которую игрок видит на экране. Предполагается, что существуют отдельные состояния для игры, главного меню.

Состояние игры содержит сслыку на текущий уровень (LevelPtr), экземпляр графического интерфейса (GuiPtr).

```
class MyState : public State
{
public:
	MyState()
	{
		// Создать графический интерфейс
		gcn::ContainerPtr top(new gcn::Container());
		GetGUI()->SetTop(top);
	}

	virtual void OnUpdate(float elapsedTime) override
	{
		// реализовать логику состояния
	}
private:
};
```

Работа приложения завершится сразу после того, как стек состояний окажется пустым.

Для обработки событий графического интерфейса состояние должно реализовать методы интерфейса gcn::MouseListener.